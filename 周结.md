## 本周主要工作
- 完成 GM6020 电机驱动代码的编写与调试，确保其能够正确接收和发送 CAN 报文，实现对电机的位置/速度闭环控制。
- 优化 PID 控制算法，提升电机运动的稳定性

## 遇到问题
1. 在实现 GM6020 电机的 CAN 通信时，遇到报文解析错误的问题，导致无法正确读取电机的反馈数据。
   - 解决方法：decode()函数写错,已修正
2. 电机无法运动,经ozone调试发现电流非常小
   - 解决方法:该电机一秒闪烁频率为3,ID为3,由用户手册知应通过data[4]和data[5]向电机发送电流值,之前误以为是data[0]和data[1]
3. C跟C++混合编译时，出现大量报错。
   - 解决方法：#ifdef __cplusplus 
              extern "C" { 
              #endif
              // C 代码
              #ifdef __cplusplus
              }
              #endif
              (告诉 C++ 编译器按照 C 的方式处理函数，避免名字修饰，使得函数能在 C 和 C++ 之间兼容。)
  - 需要使用的情况:
      1. C头文件被C++代码包含时,在.h里加
      2. C++代码提供C接口时
      3. C文件需要使用hpp里的函数时
4. 在位置环控制中，未考虑过零问题，导致电机在接近-π 到 π边界时出现PID跳变
   - 解决方法：在位置误差计算中添加环绕处理逻辑，确保误差始终在 -π 到 π 范围内。
   - 位置闭环任务的π/4 到-π 就出现了这种现象,目前仍未解决
5. 将原始编码器值 (0-8191) 转换为弧度制角度时,angle_ 范围转换为 -π 到 π,转换函数编写逻辑出错,导致电机角度异常

## 任务实现思路
1. 在main.c中只需要在while循环前使用MotorControl_Init(),通过外部cpp文件定义初始化MotorControl控制任务,打开FDCAN通信,配置FDCAN滤波器,启动CAN接收中断,启动定时器
2. 在定时器中断回调函数中调用MotorControl_Task()实现周期性任务调度,此为主控制任务,包含速度闭环,位置闭环的实现代码
3. 定义GM6020类,封装电机的基本属性和方法,包括设置目标位置/速度,读取反馈数据等
4. 定义PID类,实现PID控制算法,包含位置环和速度环的计算方法
5. HW_fdcan.cpp文件中实现CAN报文的接收与发送功能,确保能够正确在can接收中断中decode电机反馈的数据
6. 对于速度环和角度环控制最后其实都化归到电流值的控制,通过电流值改变电机运动状态,用PID计算出需要的电流值current_input,再通过motor_m1.setInput(current_input);设置电机的输入电流值
7. 数据封装,encode函数处理电机类当中的电流值,打包进data[]数组中,FdcanSendMsg函数启动发送过程,实现C板对电机的控制

>P.S. 句柄是指向外设的结构体指针,通过句柄可以访问和配置外设的寄存器和功能.